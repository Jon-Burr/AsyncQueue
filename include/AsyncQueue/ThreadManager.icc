namespace AsyncQueue {

    template <typename F, typename... Args>
    std::future<void> ThreadManager::loop(F &&f, Args &&...args) {
        std::function<void()> f_ = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        // Resolve the overloaded function for async
        void (ThreadManager::*doLoop)(std::function<void()>) = &ThreadManager::doLoop;
        return std::async(doLoop, this, f_);
    }

    template <typename F, typename... Args>
    std::future<void> ThreadManager::loop(std::condition_variable &cv, F f, Args &&...args) {
        std::function<void()> f_ = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        // Resolve the overloaded function for async
        void (ThreadManager::*doLoop)(std::condition_variable &, std::function<void()>) =
                &ThreadManager::doLoop;
        return std::async(doLoop, this, std::ref(cv), f_);
    }
    template <typename F, typename... Args>
    std::future<TaskStatus> ThreadManager::loopTask(F &&f, Args &&...args) {
        std::function<TaskStatus()> f_ = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        // Resolve the overloaded function for async
        TaskStatus (ThreadManager::*doLoopTask)(std::function<TaskStatus()>) =
                &ThreadManager::doLoopTask;
        return std::async(doLoopTask, this, f_);
    }
    template <typename F, typename... Args>
    std::future<TaskStatus> ThreadManager::loopTask(
            std::condition_variable &cv, F &&f, Args &&...args) {
        std::function<TaskStatus()> f_ = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        // Resolve the overloaded function for async
        TaskStatus (ThreadManager::*doLoopTask)(
                std::condition_variable &, std::function<TaskStatus()>) =
                &ThreadManager::doLoopTask;
        return std::async(doLoopTask, this, std::ref(cv), f_);
    }

} // namespace AsyncQueue