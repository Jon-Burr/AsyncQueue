#include <cassert>

namespace AsyncQueue {
    template <typename T> void AsyncQueue<T>::push(const T &value) {
        auto lock = this->lock();
        m_queue.push(value);
        lock.unlock();
        m_cv.notify_one();
    }

    template <typename T>
    void AsyncQueue<T>::push(const T &value, const std::unique_lock<std::mutex> &lock) {
        assert(lock.owns_lock() && lock.mutex() == &m_mutex);
        m_queue.push(value);
        m_cv.notify_one();
    }

    template <typename T> void AsyncQueue<T>::push(T &&value) {
        auto lock = this->lock();
        m_queue.push(std::move(value));
        lock.unlock();
        m_cv.notify_one();
    }

    template <typename T>
    void AsyncQueue<T>::push(T &&value, const std::unique_lock<std::mutex> &lock) {
        assert(lock.owns_lock() && lock.mutex() == &m_mutex);
        m_queue.push(std::move(value));
        m_cv.notify_one();
    }

    template <typename T> std::optional<T> AsyncQueue<T>::extract() {
        return extract(this->lock());
    }

    template <typename T>
    std::optional<T> AsyncQueue<T>::extract(const std::unique_lock<std::mutex> &lock) {
        assert(lock.owns_lock() && lock.mutex() == &m_mutex);
        if (m_queue.size()) {
            std::optional<T> value(std::move(m_queue.front()));
            m_queue.pop();
            return value;
        }
        return {};
    }
    template <typename T>
    template <typename F, typename... Args>
    std::future<TaskStatus> AsyncQueue<T>::loopProducer(
            ThreadManager &mgr, F &&producer, Args &&...args) {
        static_assert(
                std::is_invocable_r_v<TaskStatus, F, AsyncQueue<T> &, Args...>,
                "The passed function is incorrect");
        std::function<TaskStatus(AsyncQueue<T> &)> f = std::bind(
                std::forward<F>(producer), std::placeholders::_1, std::forward<Args>(args)...);
        return loopProducer(mgr, f);
    }
    template <typename T>
    template <typename F, typename... Args>
    std::future<TaskStatus> AsyncQueue<T>::loopProducer(
            ThreadManager &mgr, std::condition_variable &cv, F &&producer, Args &&...args) {
        static_assert(
                std::is_invocable_r_v<TaskStatus, F, AsyncQueue<T> &, Args...>,
                "The passed function is incorrect");
        std::function<TaskStatus(AsyncQueue<T> &)> f = std::bind(
                std::forward<F>(producer), std::placeholders::_1, std::forward<Args>(args)...);
        return loopProducer(mgr, cv, f);
    }
    template <typename T>
    template <typename Rep, typename Period, typename F, typename... Args>
    std::future<TaskStatus> AsyncQueue<T>::loopProducer(
            ThreadManager &mgr, const std::chrono::duration<Rep, Period> &heartbeat, F &&producer,
            Args &&...args) {
        static_assert(
                std::is_invocable_r_v<TaskStatus, F, AsyncQueue<T> &, Args...>,
                "The passed function is incorrect");
        std::function<TaskStatus(AsyncQueue<T> &)> f = std::bind(
                std::forward<F>(producer), std::placeholders::_1, std::forward<Args>(args)...);
        return mgr.loopTask(heartbeat, f, std::ref(*this));
    }

    template <typename T>
    template <typename F, typename... Args>
    std::future<TaskStatus> AsyncQueue<T>::loopConsumer(
            ThreadManager &mgr, F &&consumer, Args &&...args) {
        std::function<TaskStatus(const T &)> f = std::bind(
                std::forward<F>(consumer), std::placeholders::_1, std::forward<Args>(args)...);
        return loopConsumer(mgr, f);
    }

    template <typename T>
    std::future<TaskStatus> AsyncQueue<T>::loopProducer(
            ThreadManager &mgr, std::function<TaskStatus(AsyncQueue<T> &)> producer) {
        return mgr.loopTask(producer, std::ref(*this));
    }

    template <typename T>
    std::future<TaskStatus> AsyncQueue<T>::loopProducer(
            ThreadManager &mgr, std::condition_variable &cv,
            std::function<TaskStatus(AsyncQueue<T> &)> producer) {
        return mgr.loopTask(cv, producer, std::ref(*this));
    }

    template <typename T>
    std::future<TaskStatus> AsyncQueue<T>::loopConsumer(
            ThreadManager &mgr, std::function<TaskStatus(const T &)> consumer) {
        return mgr.loopTask(cv(), &AsyncQueue::doLoopConsumer, this, consumer);
    }

    template <typename T>
    TaskStatus AsyncQueue<T>::doLoopConsumer(std::function<TaskStatus(const T &)> consumer) {
        auto lock_ = this->lock();
        while (std::optional<T> value = extract(lock_)) {
            // Unlock while the consumer deals with the value
            lock_.unlock();
            switch (consumer(*value)) {
            case TaskStatus::CONTINUE:
                break;
            case TaskStatus::HALT:
                return TaskStatus::HALT;
            case TaskStatus::ABORT:
                return TaskStatus::ABORT;
            }
            // Reacquire the lock before trying to extract another value
            lock_.lock();
        }
        cv().wait(lock_);
        return TaskStatus::CONTINUE;
    }
} // namespace AsyncQueue