#include <type_traits>

namespace AsyncQueue {

    template <typename F, typename... Args>
    std::future<void> ThreadManager::loop(F &&f, Args &&...args) {
        using namespace std::chrono_literals;
        return loop(0ns, std::forward<F>(f), std::forward<Args>(args)...);
    }

    template <typename F, typename... Args>
    std::future<void> ThreadManager::loop(std::condition_variable &cv, F &&f, Args &&...args) {
        using namespace std::chrono_literals;
        std::function<void()> f_;
        if constexpr (std::is_lvalue_reference_v<F>)
            f_ = std::bind(std::ref(f), std::forward<Args>(args)...);
        else
            f_ = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        // Resolve the overloaded function for async
        void (ThreadManager::*doLoop)(
                std::condition_variable &, std::chrono::nanoseconds, std::function<void()>) =
                &ThreadManager::doLoop;
        // Given that this loop is already controlled by a CV there's no need for a heartbeat
        return std::async(doLoop, this, std::ref(cv), 0ns, f_);
    }

    template <typename Rep, typename Ratio, typename F, typename... Args>
    std::future<void> ThreadManager::loop(
            std::chrono::duration<Rep, Ratio> heartbeat, F &&f, Args &&...args) {
        std::function<void()> f_;
        if constexpr (std::is_lvalue_reference_v<F>)
            f_ = std::bind(std::ref(f), std::forward<Args>(args)...);
        else
            f_ = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        // Resolve the overloaded function for async
        void (ThreadManager::*doLoop)(std::chrono::nanoseconds, std::function<void()>) =
                &ThreadManager::doLoop;
        return std::async(
                doLoop, this, std::chrono::duration_cast<std::chrono::nanoseconds>(heartbeat), f_);
    }

    template <typename F, typename... Args>
    std::future<TaskStatus> ThreadManager::loopTask(F &&f, Args &&...args) {
        using namespace std::chrono_literals;
        return loopTask(0ns, std::forward<F>(f), std::forward<Args>(args)...);
    }

    template <typename F, typename... Args>
    std::future<TaskStatus> ThreadManager::loopTask(
            std::condition_variable &cv, F &&f, Args &&...args) {
        using namespace std::chrono_literals;
        std::function<TaskStatus()> f_;
        if constexpr (std::is_lvalue_reference_v<F>)
            f_ = std::bind(std::ref(f), std::forward<Args>(args)...);
        else
            f_ = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        // Resolve the overloaded function for async
        TaskStatus (ThreadManager::*doLoopTask)(
                std::condition_variable &, std::chrono::nanoseconds, std::function<TaskStatus()>) =
                &ThreadManager::doLoopTask;
        return std::async(doLoopTask, this, std::ref(cv), 0ns, f_);
    }

    template <typename Rep, typename Ratio, typename F, typename... Args>
    std::future<TaskStatus> ThreadManager::loopTask(
            std::chrono::duration<Rep, Ratio> heartbeat, F &&f, Args &&...args) {
        std::function<TaskStatus()> f_;
        if constexpr (std::is_lvalue_reference_v<F>)
            f_ = std::bind(std::ref(f), std::forward<Args>(args)...);
        else
            f_ = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        // Resolve the overloaded function for async
        TaskStatus (ThreadManager::*doLoopTask)(
                std::chrono::nanoseconds, std::function<TaskStatus()>) = &ThreadManager::doLoopTask;
        return std::async(
                doLoopTask, this, std::chrono::duration_cast<std::chrono::nanoseconds>(heartbeat),
                f_);
    }

    template <typename Rep, typename Period>
    std::future<bool> ThreadManager::setTimeout(
            const std::chrono::duration<Rep, Period> &duration) {
        return setTimeout(std::chrono::steady_clock::now() + duration);
    }

} // namespace AsyncQueue